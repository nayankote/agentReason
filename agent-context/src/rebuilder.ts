import type { ThinkingEvent } from './schema.js'

/**
 * Builds the ## Agent Context markdown section from a list of ThinkingEvents.
 * Events are grouped by file (files_affected), or placed under 'General' if
 * files_affected is empty.
 */
export function buildClaudeMdSection(events: ThinkingEvent[]): string {
  const grouped = new Map<string, ThinkingEvent[]>()

  for (const event of events) {
    const files = event.files_affected.length > 0 ? event.files_affected : ['General']
    for (const file of files) {
      if (!grouped.has(file)) {
        grouped.set(file, [])
      }
      grouped.get(file)!.push(event)
    }
  }

  const lines: string[] = [
    '## Agent Context',
    '',
    '> Auto-generated by agent-context. Do not edit manually.',
    ''
  ]

  for (const [file, fileEvents] of grouped) {
    lines.push(`### ${file}`)
    lines.push('')
    for (const event of fileEvents) {
      const date = event.timestamp.slice(0, 10)
      lines.push(`- **[${event.type}]** ${event.summary} *(${date})*`)
    }
    lines.push('')
  }

  return lines.join('\n')
}

/**
 * Injects a new ## Agent Context section into existing CLAUDE.md content.
 * If an ## Agent Context section already exists, it is replaced (up to the
 * next ## heading or end of file). Otherwise, the new section is appended.
 */
export function injectIntoClaudeMd(existing: string, newSection: string): string {
  const agentContextHeader = '## Agent Context'
  const startIndex = existing.indexOf(agentContextHeader)

  if (startIndex === -1) {
    // No existing section — append to end
    const trimmed = existing.trimEnd()
    return trimmed + '\n\n' + newSection
  }

  // Find the next ## heading after the Agent Context section
  const afterStart = startIndex + agentContextHeader.length
  const nextHeadingMatch = existing.slice(afterStart).search(/\n##\s/)

  let endIndex: number
  if (nextHeadingMatch === -1) {
    // No next ## heading — replace to end of file
    endIndex = existing.length
  } else {
    // next heading starts at the \n before ##, so we include up to that \n
    endIndex = afterStart + nextHeadingMatch + 1
  }

  const before = existing.slice(0, startIndex)
  const after = existing.slice(endIndex)

  // Ensure a clean join: before ends with newline(s), after starts with ## heading
  const beforeTrimmed = before.trimEnd()
  const afterTrimmed = after.trimStart()

  if (afterTrimmed.length > 0) {
    return beforeTrimmed + '\n\n' + newSection + '\n' + afterTrimmed
  } else {
    return beforeTrimmed + '\n\n' + newSection
  }
}
